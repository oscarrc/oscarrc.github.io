---
import type { MarkdownHeading } from "astro";

interface Props {
  headings: MarkdownHeading[];
  class?: string;
}

const { headings, class: className } = Astro.props;

const filteredHeadings = headings.filter(
  ({ depth }) => depth === 2 || depth === 3
);

// Build nested structure with reduce (h2 items with children array)
const nestedHeadings = filteredHeadings.reduce(
  (acc: Array<MarkdownHeading & { children: MarkdownHeading[] }>, h) => {
    if (h.depth === 2) {
      acc.push({ ...h, children: [] });
    } else {
      const last = acc[acc.length - 1];
      if (last) {
        last.children.push(h);
      } else {
        acc.push({ ...h, depth: 2, children: [] });
      }
    }
    return acc;
  },
  []
);
---

<nav
  class={`card card-xs space-y-4 mx-auto max-w-4xl 2xl:max-w-xs w-full border rounded-box ${className}`}
>
  <h6
    class="absolute bg-base-100 -top-2.5 left-3 px-2 card-title flex-col text-sm items-start gap-0"
  >
    Table of Contents
  </h6>

  <div class="w-full min-w-0">
    <ul class="menu menu-xs p-4 pt-6 w-full min-w-0 box-border">
      {
        nestedHeadings.map((h2, index) => (
          <li class="min-w-0 w-full overflow-hidden">
            {h2.children && h2.children.length > 0 ? (
              <details open={index === 0} class="w-full min-w-0" data-details-section>
                <summary class="min-w-0 w-full overflow-hidden">
                  <a
                    href={`#${h2.slug}`}
                    data-toc-link={`#${h2.slug}`}
                    class="truncate block text-primary toc-link"
                  >
                    {h2.text}
                  </a>
                </summary>
                <ul class="w-full min-w-0">
                  {h2.children.map((h3) => (
                    <li class="min-w-0 w-full overflow-hidden">
                      <a
                        href={`#${h3.slug}`}
                        data-toc-link={`#${h3.slug}`}
                        class="truncate block text-accent toc-link"
                      >
                        {h3.text}
                      </a>
                    </li>
                  ))}
                </ul>
              </details>
            ) : (
              <a
                href={`#${h2.slug}`}
                data-toc-link={`#${h2.slug}`}
                class="truncate block text-primary min-w-0 w-full toc-link"
              >
                {h2.text}
              </a>
            )}
          </li>
        ))
      }
    </ul>
  </div>
</nav>

<script>
  function initScrollSpy() {
    const tocLinks = document.querySelectorAll("[data-toc-link]");
    if (tocLinks.length === 0) return;

    const headings = Array.from(tocLinks)
      .map((link) => {
        const id = link.getAttribute("href")?.slice(1);
        return id ? document.getElementById(id) : null;
      })
      .filter((heading) => heading !== null);

    if (headings.length === 0) return;

    // Helper function to find the parent details element for a link
    const findParentDetails = (link: HTMLAnchorElement) => {
      let parent = link.closest("details");
      return parent;
    };

    // Helper function to update details open/closed state
    const updateDetailsState = (activeLink: HTMLAnchorElement | null) => {
      if (!activeLink) return;

      const activeDetails = findParentDetails(activeLink);
      
      // Only open the active details section, don't close others
      // This preserves manually opened sections and allows multiple to be open
      if (activeDetails && !activeDetails.open) {
        activeDetails.open = true;
      }
    };

    const updateActiveLink = () => {
      let activeHeading = null;
      const scrollPosition = window.scrollY + 100; // Offset for better UX

      for (let i = headings.length - 1; i >= 0; i--) {
        const heading = headings[i];
        if (heading && heading.offsetTop <= scrollPosition) {
          activeHeading = heading;
          break;
        }
      }

      if (!activeHeading && headings.length > 0) {
        activeHeading = headings[0];
      }

      let activeLink = null;

      tocLinks.forEach((link) => {
        link.classList.remove("active", "font-semibold");
        if (
          activeHeading &&
          link.getAttribute("href") === `#${activeHeading.id}`
        ) {
          link.classList.add("active", "font-semibold");
          activeLink = link;
        }
      });

      updateDetailsState(activeLink);
    };

    const observerOptions = {
      rootMargin: "-20% 0px -70% 0px",
      threshold: 0,
    };

    const observer = new IntersectionObserver((entries) => {
      const visibleEntries = entries.filter((e) => e.isIntersecting);
      if (visibleEntries.length === 0) {
        updateActiveLink();
        return;
      }

      visibleEntries.sort((a, b) => {
        if (a.intersectionRatio !== b.intersectionRatio) {
          return b.intersectionRatio - a.intersectionRatio;
        }
        return a.boundingClientRect.top - b.boundingClientRect.top;
      });

      const activeHeading = visibleEntries[0]?.target;
      let activeLink: HTMLAnchorElement | null = null;

      tocLinks.forEach((link) => {
        link.classList.remove("active", "font-semibold");
        if (
          activeHeading &&
          link.getAttribute("href") === `#${activeHeading.id}`
        ) {
          link.classList.add("active", "font-semibold");
          activeLink = link as HTMLAnchorElement;
        }
      });

      updateDetailsState(activeLink);
    }, observerOptions);

    headings.forEach((heading) => observer.observe(heading));

    // Fallback: update on scroll for headings that might not be observed
    let scrollTimeout: number;
    
    window.addEventListener(
      "scroll",
      () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = window.setTimeout(updateActiveLink, 100);
      },
      { passive: true }
    );

    // Initial update
    updateActiveLink();
  }

  // Ensure DOM is ready - use requestAnimationFrame for better timing
  function runInit() {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        initScrollSpy();
      });
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", runInit);
  } else {
    runInit();
  }
</script>

<style>
  .toc-link {
    transition: all 0.2s ease;
  }

  .toc-link.active {
    color: hsl(var(--p)); /* Primary color for active link */
  }

  .toc-link.active.text-accent {
    color: hsl(var(--a)); /* Accent color for active h3 links */
  }
</style>
